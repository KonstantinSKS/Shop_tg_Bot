import os

# from admin_panel.django_settings.settings import MEDIA_ROOT
from admin_panel.django_settings import settings

from aiogram.types import FSInputFile
from aiogram.fsm.context import FSMContext
from aiogram.utils.markdown import hbold, hitalic
from aiogram.types import InlineKeyboardMarkup
from aiogram import types, Router, F
from aiogram.filters import Command
from aiogram.exceptions import TelegramBadRequest

from tg_bot.db import db_commands as db
from tg_bot.loader import bot
from tg_bot.settings_logger import logger
# from tg_bot.states.all_states import StateUser
from tg_bot.keyboards import inline as inline_kb
from tg_bot.keyboards.callback_data import (
    CategoriesCallback, SubcategoryCallback, ProductCallback, BackCallback)
from tg_bot.misc.utils import check_sub_channel
from tg_bot.misc import constants as const
from tg_bot.keyboards.pagination import paginate_products


shoping_router = Router()


@shoping_router.callback_query(CategoriesCallback.filter())  # F.level == "categories"
async def get_categories(call: types.CallbackQuery, callback_data: CategoriesCallback):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π —Ç–æ–≤–∞—Ä–æ–≤ —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π."""

    categories = await db.get_all_categories()
    if not categories:
        await call.message.answer("–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.") # cache_time=3
        return

    await call.message.edit_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:",
        reply_markup=inline_kb.categories_kb(categories, callback_data.page)
    )


@shoping_router.callback_query(SubcategoryCallback.filter())
async def show_category(call: types.CallbackQuery, callback_data: SubcategoryCallback):
    """–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏ —Å–ø–∏—Å–æ–∫ –µ—ë –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–π —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π."""

    category = await db.get_category(callback_data.category_id)
    subcategories = await db.get_all_subcategories(callback_data.category_id)
    if not subcategories:
        await call.message.answer("–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.") #cache_time=3
        return

    text = f"*{category.title}*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—é:"
    keyboard = inline_kb.subcategories_kb(subcategories, callback_data.category_id, callback_data.page)

    await call.message.edit_text(
        text=text,
        reply_markup=keyboard,
        parse_mode="Markdown"
    )


# @shoping_router.callback_query(F.data.startswith("products_"))
# @shoping_router.callback_query(F.data.startswith("subcategory_"))
# async def show_products(call: types.CallbackQuery):
#     """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∂–∞—Ç–∏–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –≤—ã–≤–æ–¥–∏—Ç —Ç–æ–≤–∞—Ä—ã."""
#     print("call.data:", call.data)
#     subcategory_id = int(call.data.split("_")[-1])
#     print("subcategory_id:", subcategory_id)

#     products = await db.get_all_products(subcategory_id)
#     # products = list(products)  # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º QuerySet –≤ —Å–ø–∏—Å–æ–∫

#     if not products:
#         await call.message.answer("‚ùå –í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –Ω–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤.")
#         return

#     page = 1
#     # paginated_products, pagination_buttons = paginate_products(products, page, 1, f"product_{subcategory_id}")
#     # for product in products:

#     product = products[0]  # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π —Ç–æ–≤–∞—Ä –Ω–∞ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ
#     caption = f"{hbold(product.title)}\n{hitalic(product.description)}\nüí∞ –¶–µ–Ω–∞: {product.price} —Ä."

#     keyboard = inline_kb.product_kb(product, page)  # subcategory_id
#     # keyboard = InlineKeyboardMarkup(inline_keyboard=[pagination_buttons])
#     image_file = FSInputFile(product.image.path)
#     await call.message.answer_photo(photo=image_file, caption=caption, reply_markup=keyboard)


# @shoping_router.callback_query(F.data.startswith("products_"))
# @shoping_router.callback_query(F.data.startswith("subcategory_"))
# async def show_products(call: types.CallbackQuery):
#     """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∂–∞—Ç–∏–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –≤—ã–≤–æ–¥–∏—Ç —Ç–æ–≤–∞—Ä—ã."""
#     print("call.data:", call.data)

#     data_parts = call.data.split("_")

#     if len(data_parts) == 2:  # –ù–∞–∂–∞—Ç–∏–µ –Ω–∞ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—é
#         subcategory_id = int(data_parts[1])
#         page = 1  # –ù–∞—á–∏–Ω–∞–µ–º —Å –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
#     elif len(data_parts) == 4:  # –ù–∞–∂–∞—Ç–∏–µ –Ω–∞ –∫–Ω–æ–ø–∫—É "–≤–ø–µ—Ä–µ–¥" –∏–ª–∏ "–Ω–∞–∑–∞–¥"
#         subcategory_id = int(data_parts[1])
#         page = int(data_parts[3])  # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
#     else:
#         print("–û—à–∏–±–∫–∞ –≤ callback_data:", call.data)
#         return

#     print(f"subcategory_id: {subcategory_id}, page: {page}")

#     products = await db.get_all_products(subcategory_id)
#     if not products:
#         await call.message.answer("‚ùå –í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –Ω–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤.")
#         return

#     if page < 1 or page > len(products):
#         return  # –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –≤—ã—Ö–æ–¥ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã —Å–ø–∏—Å–∫–∞

#     product = products[page - 1]  # –í—ã–±–∏—Ä–∞–µ–º –Ω—É–∂–Ω—ã–π —Ç–æ–≤–∞—Ä
#     caption = f"{hbold(product.title)}\n{hitalic(product.description)}\nüí∞ –¶–µ–Ω–∞: {product.price} —Ä."

#     keyboard = inline_kb.product_kb(product.id, subcategory_id, page)
#     image_file = FSInputFile(product.image.path)

#     await call.message.edit_media(
#         types.InputMediaPhoto(media=image_file, caption=caption),
#         reply_markup=keyboard
#     )


# @shoping_router.callback_query(ProductCallback.filter())
# async def show_product(call: types.CallbackQuery, callback_data: ProductCallback):
#     """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∂–∞—Ç–∏–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –≤—ã–≤–æ–¥–∏—Ç —Ç–æ–≤–∞—Ä—ã."""

#     products = await db.get_all_products(callback_data.subcategory_id)
#     if not products:
#         await call.message.answer("‚ùå –í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –Ω–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤.")
#         return
#     # product = products[callback_data.page - 1]
#     product = products[0]
#     total_products = len(products)

#     caption = f"{hbold(product.title)}\n{hitalic(product.description)}\nüí∞ –¶–µ–Ω–∞: {product.price} —Ä."
#     keyboard = inline_kb.products_kb(products, callback_data.subcategory_id, callback_data.page)  # total_products

#     # if product.image:
#     image_file = FSInputFile(product.image.path)
#     await call.message.edit_media(
#         types.InputMediaPhoto(media=image_file, caption=caption),
#         rlepy_markup=keyboard
#     )
    # await call.message.edit_text(text=caption, rlepy_markup=keyboard)


    # if product.image and product.image.path:
    #     try:
    #         image_file = FSInputFile(product.image.path)
    #         await call.message.edit_media(
    #             types.InputMediaPhoto(media=image_file, caption=caption, parse_mode="Markdown"),
    #             reply_markup=keyboard
    #         )
    #     except TelegramBadRequest:
    #         # –ï—Å–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –ø—Ä–æ—Å—Ç–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç
    #         await call.message.edit_text(text=caption, reply_markup=keyboard, parse_mode="Markdown")
    # else:
    #     # –ï—Å–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ—Ç, —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç
    #     await call.message.edit_text(text=caption, reply_markup=keyboard, parse_mode="Markdown")

@shoping_router.callback_query(ProductCallback.filter())
async def show_product(call: types.CallbackQuery, callback_data: ProductCallback):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∂–∞—Ç–∏–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –≤—ã–≤–æ–¥–∏—Ç —Ç–æ–≤–∞—Ä—ã."""

    products = await db.get_all_products(callback_data.subcategory_id)
    if not products:
        await call.message.answer("‚ùå –í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –Ω–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤.")
        return
    product = products[0]
    caption = f"{hbold(product.title)}\n{hitalic(product.description)}\nüí∞ –¶–µ–Ω–∞: {product.price} —Ä."
    keyboard = inline_kb.products_kb(products, callback_data.subcategory_id, callback_data.page)
    image_file = FSInputFile(product.image.path)
    await call.message.edit_media(
        types.InputMediaPhoto(media=image_file, caption=caption),
        rlepy_markup=keyboard
    )
